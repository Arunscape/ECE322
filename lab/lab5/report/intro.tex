The purpose of this lab was to serve as an introduction to integration testing.
Integration testing is a logical extension of the previous lab, in which we did
unit testing. This also allows us to build on the JUnit skills we learned in the
previous lab. We were also introduced to the idea of mocking, using the Mockito
library to mock out relationships between classes as we desire. Generally, there
are two strategies to integration testing. The first is \textit{Non-incremental}
testing, also known as Big Bang testing. With this strategy, each module is
tested individually, and then there is one final test where the entire system is
tested as a whole. The secons integration testing approach is
\textit{Incremental} testing, in which we combine the next module to be tested
with the set of previously tested modules before running tests. This can be done
in either a bottum up or top down approach. In this lab, a simple command-line
database program was tested. There are 7 modules which make up the system.
Module A is responsible for the GUI, B for opening, C for sorting, D for
modifying, E for exiting, F for displaying, and G for updating data. Files in
the database contain one entry per line, which are comma separated. Both testing
strategies were used to test the application in this lab. Big bang testing was
done in the first part, and we chose the Bottup-up incremental testing strategy
for the second portion of the lab. Where possible, the tests were crafted to
cover the full functionality of the program, including statement coverage. The
exceptions are modules A and B, where it was not feasable to cover some lines.
The case with Module A was that line 147 cannot be covered because when the
program exits, an exception is thrown, which halts execution. With Module B,
testing lines 39-42 when an IO Exception is caught does not need to be tested,
because there is already code which handles the case when a file is not found.
Furthermore, this situation was neer encountered in our testing, due to the
error handing when a file is not found. Additionally, the only code that gets
run if this IO Exception somehow gets thrown are library functions (Printing to
stdout, and printing a stacktrace of an error), and these library functions are
likely already tested extensively, otherwise programmers would not trust them. 

The goal was to become familiar with the JUnit testing library in Java, as well
as using an orthogonal table to come up with test cases for pairwise testing,
and using a tool named PICT (Pairwise Independent Combinatorial Tool) to
generate pairwise tests. White-box testing, in contrast to Black-Box testing
focuses on testing the internal parts of an application. That is, instead of
having only an outsider view of the application, we use the insight we know
about the application from knowing its source code and implementation details
to come up with tests to test the program for failures. We also look at
pairwise testing, which is an efficient way to come up with a set of test cases
that covers all possible combinations of pairs of inputs.  In the first part, a
program written in Java was tested, named Bisect.  This program implements the
well-known bisection algorithm in mathematics to find the root of a polynomial
in an interval where the polynomial crosses $x=0$. The source code was
analyzed, and test cases were generated test for failures in the program. Not
only were the test cases testing the functionality of the application, but we
also had to ensure that together, all lines of code in the program were
executed, and all branches were taken. Additionally, a control flow graph was
generated. For the second part of this lab, a conceptual exercise was done to
think about and discuss the benefits of pairwise testing versus exhaustive
testing, and the effectiveness of the tests generated using this method. We
also compared the tests generated by the PICT tool versus tests made using a
standard orthogonal array.

